# Примечания к выпуску

- [Схема управления версиями](#versioning-scheme)
- [Политика поддержки](#support-policy)
- [Laravel 8](#laravel-8)

<a name="versioning-scheme"></a>
## Схема управления версиями

Laravel и другие его собственные пакеты следуют [Semantic Versioning](https://semver.org). Основные выпуски фреймворка выпускаются каждые шесть месяцев (~март и ~сентябрь), в то время как второстепенные релизы и патчи могут выпускаться каждую неделю. Незначительные выпуски и выпуски исправлений **никогда** не должны содержать критических изменений.

При ссылке на фреймворк Laravel или его компоненты из Вашего приложения или пакета Вы всегда должны использовать ограничение версии, такое как `^8.0`, поскольку основные выпуски Laravel действительно включают критические изменения. Однако мы всегда стремимся к тому, чтобы Вы могли выполнить обновление до новой основной версии в течение одного дня или меньше.

<a name="support-policy"></a>
## Политика поддержки

Для выпусков LTS, таких как Laravel 6, исправления ошибок предоставляются на 2 года, а исправления безопасности - на 3 года. Эти выпуски обеспечивают самый продолжительный период поддержки и обслуживания. Для общих выпусков исправления ошибок предоставляются на 7 месяцев, а исправления безопасности - на 1 год. Для всех дополнительных библиотек, включая Lumen, только последний выпуск получает исправления ошибок. Кроме того, просмотрите версии базы данных [поддерживаемые Laravel](/docs/{{version}}/database#introduction).

| Версия | Релиз | Исправления ошибок до | Исправления безопасности до |
| --- | --- | --- | --- |
| 6 (LTS) | 3 Сентября, 2019 | 5 Октября, 2021 | 3 Сентября, 2022 |
| 7 | 3 Марта, 2020 | 6 Октября, 2020 | 3 Марта, 2021 |
| 8 | 8 Сентября, 2020 | 65 Апреля, 2021 | 8 Сентября, 2021 |

<a name="laravel-8"></a>
## Laravel 8

Laravel 8 продолжает улучшения, сделанные в Laravel 7.x, представляя Laravel Jetstream, классы фабрики моделей, сжатие миграции, пакетирование заданий, улучшенное ограничение скорости, улучшения очереди, динамические компоненты Blade, представления разбивки на страницы Tailwind, помощники по тестированию времени, улучшения в `artisan serve`, улучшения прослушивателя событий и множество других исправлений ошибок и улучшений удобства использования.

<a name="laravel-jetstream"></a>
### Laravel Jetstream

_Laravel Jetstream был написан [Taylor Otwell](https://github.com/taylorotwell)_.

[Laravel Jetstream](https://jetstream.laravel.com) - это красиво оформленный каркас приложений для Laravel. Jetstream обеспечивает идеальную отправную точку для Вашего следующего проекта и включает в себя вход в систему, регистрацию, проверку электронной почты, двухфакторную аутентификацию, управление сеансом, поддержку API через Laravel Sanctum и дополнительное управление командой. Laravel Jetstream заменяет и улучшает устаревшие конструкции пользовательского интерфейса аутентификации, доступные для предыдущих версий Laravel.

Jetstream разработан с использованием [Tailwind CSS](https://tailwindcss.com) и предлагает на Ваш выбор [Livewire](https://laravel-livewire.com) или [Inertia](https://inertiajs.com).

<a name="models-directory"></a>
### Каталог Моделей

По многочисленным просьбам сообщества скелет приложения Laravel по умолчанию теперь содержит каталог `app/Models`. Надеемся, Вам понравится этот новый дом для Ваших моделей Eloquent! Все соответствующие команды генератора были обновлены, чтобы предполагать, что модели существуют в каталоге `app/Models`, если он существует. Если каталог не существует, фреймворк предполагает, что Ваши модели должны быть помещены в каталог `app`.

<a name="model-factory-classes"></a>
### Классы фабрики моделей

_Классы фабрики моделей были предоставлены [Taylor Otwell](https://github.com/taylorotwell)_.

Eloquent [фабрики моделей](/docs/{{version}}/database-testing#creating-factories) были полностью переписаны как фабрики на основе классов и улучшены для поддержки первоклассных отношений. Например, `UserFactory`, включенный в Laravel, написан так:

    <?php

    namespace Database\Factories;

    use App\Models\User;
    use Illuminate\Database\Eloquent\Factories\Factory;
    use Illuminate\Support\Str;

    class UserFactory extends Factory
    {
        /**
         * The name of the factory's corresponding model.
         *
         * @var string
         */
        protected $model = User::class;

        /**
         * Define the model's default state.
         *
         * @return array
         */
        public function definition()
        {
            return [
                'name' => $this->faker->name,
                'email' => $this->faker->unique()->safeEmail,
                'email_verified_at' => now(),
                'password' => '$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', // password
                'remember_token' => Str::random(10),
            ];
        }
    }

Благодаря новому трейту `HasFactory`, доступному для сгенерированных моделей, фабрика моделей может использоваться следующим образом:

    use App\Models\User;

    User::factory()->count(50)->create();

Поскольку фабрики моделей теперь являются простыми классами PHP, преобразования состояний могут быть записаны как методы класса. Кроме того, при необходимости Вы можете добавить любые другие вспомогательные классы в фабрику моделей Eloquent.

Например, Ваша модель `User` может находиться в состоянии `suspended`, которое изменяет одно из значений ее атрибутов по умолчанию. Вы можете определить свои преобразования состояния, используя метод базовой фабрики `state`. Вы можете называть свой метод состояния как угодно. В конце концов, это просто типичный PHP-метод:

    /**
     * Indicate that the user is suspended.
     *
     * @return \Illuminate\Database\Eloquent\Factories\Factory
     */
    public function suspended()
    {
        return $this->state([
            'account_status' => 'suspended',
        ]);
    }

После определения метода преобразования состояния мы можем использовать его так:

    use App\Models\User;

    User::factory()->count(5)->suspended()->create();

Как уже упоминалось, фабрики моделей Laravel 8 содержат первоклассную поддержку отношений. Итак, предполагая, что наша модель `User` имеет метод отношения `posts`, мы можем просто запустить следующий код для создания пользователя с тремя сообщениями:

    $users = User::factory()
                ->hasPosts(3, [
                    'published' => false,
                ])
                ->create();

Чтобы упростить процесс обновления, был выпущен пакет [laravel/legacy-factories](https://github.com/laravel/legacy-factories), обеспечивающий поддержку предыдущей итерации фабрик моделей в Laravel 8.x.

Переписанные фабрики Laravel содержат гораздо больше функций, которые, как мы думаем, Вам понравятся. Чтобы узнать больше о фабриках моделей, обратитесь к [документации по тестированию баз данных](/docs/{{version}}/database-testing#creating-factories).

<a name="migration-squashing"></a>
### Сжатие миграции

_Сжатие миграции было предоставлено [Taylor Otwell](https://github.com/taylorotwell)_.

По мере создания приложения вы можете со временем накапливать все больше и больше миграций. Это может привести к тому, что Ваш каталог миграции станет раздутым из-за потенциально сотен миграции. Если Вы используете MySQL или PostgreSQL, теперь Вы можете «сжать» свои миграции в один файл SQL. Для начала выполните команду `schema:dump`:

    php artisan schema:dump

    // Выгрузите текущую схему базы данных и удалите все существующие миграции...
    php artisan schema:dump --prune

Когда Вы выполните эту команду, Laravel запишет файл «схемы» в Ваш каталог `database/schema`. Теперь, когда Вы пытаетесь перенести свою базу данных, и никакие другие миграции не выполнялись, Laravel сначала выполнит SQL файла схемы. После выполнения команд файла схемы Laravel выполнит все оставшиеся миграции, которые не были частью дампа схемы.

<a name="job-batching"></a>
### Пакетирование заданий

_Пакетирование заданий было предоставлено [Taylor Otwell](https://github.com/taylorotwell) и [Mohamed Said](https://github.com/themsaid)_.

Функция пакетной обработки заданий Laravel позволяет Вам легко выполнять пакет заданий, а затем выполнять некоторые действия, когда пакет заданий завершился.

Новый метод `batch` фасада `Bus` может использоваться для отправки пакета заданий. Конечно, пакетирование в первую очередь полезно в сочетании с обратными вызовами завершения. Итак, Вы можете использовать методы `then`, `catch` и `finally` для определения обратных вызовов завершения для пакета. Каждый из этих обратных вызовов получит экземпляр `Illuminate\Bus\Batch` при вызове:

    use App\Jobs\ProcessPodcast;
    use App\Podcast;
    use Illuminate\Bus\Batch;
    use Illuminate\Support\Facades\Bus;
    use Throwable;

    $batch = Bus::batch([
        new ProcessPodcast(Podcast::find(1)),
        new ProcessPodcast(Podcast::find(2)),
        new ProcessPodcast(Podcast::find(3)),
        new ProcessPodcast(Podcast::find(4)),
        new ProcessPodcast(Podcast::find(5)),
    ])->then(function (Batch $batch) {
        // Все работы успешно завершены...
    })->catch(function (Batch $batch, Throwable $e) {
        // Обнаружен сбой первого пакетного задания...
    })->finally(function (Batch $batch) {
        // Пакет завершил выполнение...
    })->dispatch();

    return $batch->id;

Чтобы узнать больше о группировке заданий, обратитесь к [документации очереди](/docs/{{version}}/queues#job-batching).

<a name="improved-rate-limiting"></a>
### Улучшенное ограничение скорости

_Улучшения ограничения скорости было предоставлено [Taylor Otwell](https://github.com/taylorotwell)_.

Функция ограничителя скорости запросов в Laravel была расширена за счет большей гибкости и мощности, при этом сохранена обратная совместимость с API промежуточного программного обеспечения `throttle` предыдущей версии.

Ограничители скорости определяются с помощью метода `for` фасада `RateLimiter`. Метод `for` принимает имя ограничителя скорости и закрытие, которое возвращает конфигурацию ограничения, которая должна применяться к маршрутам, которым назначен этот ограничитель скорости:

    use Illuminate\Cache\RateLimiting\Limit;
    use Illuminate\Support\Facades\RateLimiter;

    RateLimiter::for('global', function (Request $request) {
        return Limit::perMinute(1000);
    });

Поскольку обратные вызовы ограничителя скорости получают экземпляр входящего HTTP-запроса, Вы можете динамически создать соответствующее ограничение скорости на основе входящего запроса или аутентифицированного пользователя:

    RateLimiter::for('uploads', function (Request $request) {
        return $request->user()->vipCustomer()
                    ? Limit::none()
                    : Limit::perMinute(100);
    });

Иногда Вы можете захотеть сегментировать ограничения скорости на какое-то произвольное значение. Например, Вы можете разрешить пользователям получать доступ к заданному маршруту 100 раз в минуту на каждый IP-адрес. Для этого Вы можете использовать метод `by` при построении лимита скорости:

    RateLimiter::for('uploads', function (Request $request) {
        return $request->user()->vipCustomer()
                    ? Limit::none()
                    : Limit::perMinute(100)->by($request->ip());
    });

Ограничители скорости могут быть прикреплены к маршрутам или группам маршрутов с помощью `throttle` [middleware](/docs/{{version}}/middleware). Промежуточное программное обеспечение дроссельной заслонки принимает имя ограничителя скорости, которое Вы хотите назначить маршруту:

    Route::middleware(['throttle:uploads'])->group(function () {
        Route::post('/audio', function () {
            //
        });

        Route::post('/video', function () {
            //
        });
    });

Чтобы узнать больше об ограничении скорости, обратитесь к [документации по маршрутизации](/docs/{{version}}/routing#rate-limiting).

<a name="improved-maintenance-mode"></a>
### Улучшенный режим обслуживания

_Улучшения режима обслуживания было предоставлено [Taylor Otwell](https://github.com/taylorotwell) с вдохновением от [Spatie](https://spatie.be)_.

В предыдущих выпусках Laravel функцию режима обслуживания `php artisan down` можно было обойти с помощью «разрешенного списка» IP-адресов, которым был разрешен доступ к приложению. Эта функция была удалена в пользу более простого решения «секрет» / токен.

Находясь в режиме обслуживания, Вы можете использовать параметр `secret`, чтобы указать токен обхода режима обслуживания:

    php artisan down --secret="1630542a-246b-4b66-afa1-dd72a4c43515"

После перевода приложения в режим обслуживания Вы можете перейти к URL-адресу приложения, соответствующему этому токену, и Laravel выдаст Вашему браузеру файл cookie обхода режима обслуживания:

    https://example.com/1630542a-246b-4b66-afa1-dd72a4c43515

При доступе к этому скрытому маршруту Вы будете перенаправлены на маршрут `/` приложения. Как только cookie будет отправлен Вашему браузеру, Вы сможете просматривать приложение в обычном режиме, как если бы оно не находилось в режиме обслуживания.

<a name="pre-rendering-the-maintenance-mode-view"></a>
#### Предварительная визуализация представления режима обслуживания

Если Вы используете команду `php artisan down` во время развертывания, Ваши пользователи могут иногда сталкиваться с ошибками, если они обращаются к приложению во время обновления Ваших зависимостей Composer или других компонентов инфраструктуры. Это происходит потому, что значительная часть инфраструктуры Laravel должна загружаться, чтобы определить, находится ли Ваше приложение в режиме обслуживания, и отобразить представление режима обслуживания с помощью механизма шаблонов.

По этой причине Laravel теперь позволяет предварительно визуализировать представление режима обслуживания, которое будет возвращено в самом начале цикла запроса. Это представление отображается перед загрузкой любой из зависимостей Вашего приложения. Вы можете выполнить предварительный рендеринг шаблона по Вашему выбору, используя параметр `render` команды `down`:

    php artisan down --render="errors::503"

<a name="closure-dispatch-chain-catch"></a>
### Отправка замыкания / Цепочка `catch`

_Улучшения внес [Mohamed Said](https://github.com/themsaid)_.

Используя новый метод `catch`, теперь Вы можете предоставить закрытие, которое должно быть выполнено, если закрытие в очереди не удалось успешно завершить после исчерпания всех настроенных попыток повтора вашей очереди:

    use Throwable;

    dispatch(function () use ($podcast) {
        $podcast->publish();
    })->catch(function (Throwable $e) {
        // Эта работа не удалась...
    });

<a name="dynamic-blade-components"></a>
### Динамические компоненты Blade

_Динамические компоненты Blade были предоставлены [Taylor Otwell](https://github.com/taylorotwell)_.

Иногда Вам может потребоваться визуализировать компонент, но Вы не знаете, какой компонент следует визуализировать, до времени выполнения. В этой ситуации теперь Вы можете использовать встроенный в Laravel компонент `dynamic-component` для рендеринга компонента на основе значения или переменной времени выполнения:

    <x-dynamic-component :component="$componentName" class="mt-4" />

Чтобы узнать больше о компонентах Blade, обратитесь к [документации Blade](/docs/{{version}}/blade#components).

<a name="event-listener-improvements"></a>
### Улучшения прослушивателя событий

_Улучшения прослушивателя событий предоставлено [Taylor Otwell](https://github.com/taylorotwell)_.

Слушатели событий, основанные на замыкании, теперь могут быть зарегистрированы только путем передачи Closure методу `Event::listen`. Laravel проверит замыкание, чтобы определить, какой тип события обрабатывает слушатель:

    use App\Events\PodcastProcessed;
    use Illuminate\Support\Facades\Event;

    Event::listen(function (PodcastProcessed $event) {
        //
    });

Кроме того, прослушиватели событий на основе Closure теперь могут быть помечены как стоящие в очереди с помощью функции `Illuminate\Events\queueable`:

    use App\Events\PodcastProcessed;
    use function Illuminate\Events\queueable;
    use Illuminate\Support\Facades\Event;

    Event::listen(queueable(function (PodcastProcessed $event) {
        //
    }));

Как и задания в очереди, вы можете использовать методы `onConnection`, `onQueue` и `delay` для настройки выполнения слушателя в очереди:

    Event::listen(queueable(function (PodcastProcessed $event) {
        //
    })->onConnection('redis')->onQueue('podcasts')->delay(now()->addSeconds(10)));

Если Вы хотите обрабатывать сбои анонимного прослушивателя в очереди, Вы можете предоставить замыкание для метода `catch` при определении прослушивателя `queueable`:

    use App\Events\PodcastProcessed;
    use function Illuminate\Events\queueable;
    use Illuminate\Support\Facades\Event;
    use Throwable;

    Event::listen(queueable(function (PodcastProcessed $event) {
        //
    })->catch(function (PodcastProcessed $event, Throwable $e) {
        // The queued listener failed...
    }));

<a name="time-testing-helpers"></a>
### Помощники по тестированию времени

_Помощники по тестированию времени были предоставлены [Taylor Otwell](https://github.com/taylorotwell) с вдохновением от Ruby on Rails_.

При тестировании Вам может иногда потребоваться изменить время, возвращаемое такими помощниками, как `now` или `Illuminate\Support\Carbon::now()`. Базовый класс тестирования функций Laravel теперь включает помощников, которые позволяют Вам управлять текущим временем:

    public function testTimeCanBeManipulated()
    {
        // Путешествие в будущее...
        $this->travel(5)->milliseconds();
        $this->travel(5)->seconds();
        $this->travel(5)->minutes();
        $this->travel(5)->hours();
        $this->travel(5)->days();
        $this->travel(5)->weeks();
        $this->travel(5)->years();

        // Путешествие в прошлое...
        $this->travel(-5)->hours();

        // Путешествие в определенное время...
        $this->travelTo(now()->subHours(6));

        // Вернитесь в настоящее время...
        $this->travelBack();
    }

<a name="artisan-serve-improvements"></a>
### Улучшения Artisan `serve`

_Улучшения Artisan `serve` были предоставлены [Taylor Otwell](https://github.com/taylorotwell)_.

Команда Artisan `serve` была улучшена за счет автоматической перезагрузки при обнаружении изменений переменных среды в Вашем локальном файле `.env`. Раньше команду приходилось останавливать и перезапускать вручную.

<a name="tailwind-pagination-views"></a>
### Пагинация представлений Tailwind

Пагинатор Laravel был обновлен для использования по умолчанию фреймворка [Tailwind CSS](https://tailwindcss.com). Tailwind CSS - это настраиваемая низкоуровневая CSS-структура, которая дает Вам все строительные блоки, необходимые для создания нестандартных дизайнов без каких-либо раздражающих самоуверенных стилей, за которые Вам придется бороться. Конечно, также остаются доступными представления Bootstrap 3 и 4.

<a name="routing-namespace-updates"></a>
### Обновления пространства имен маршрутизации

В предыдущих выпусках Laravel `RouteServiceProvider` содержал свойство `$namespace`. Значение этого свойства будет автоматически добавлено к определениям маршрута контроллера и вызовам вспомогательного метода `action` / `URL::action`. В Laravel 8.x это свойство по умолчанию имеет значение `null`. Это означает, что Laravel не будет выполнять автоматическое префиксы пространства имен. Следовательно, в новых приложениях Laravel 8.x определения маршрутов контроллера должны быть определены с использованием стандартного синтаксиса вызываемого PHP:

    use App\Http\Controllers\UserController;

    Route::get('/users', [UserController::class, 'index']);

Вызовы `action` методов, связанных с действием, должны использовать один и тот же вызываемый синтаксис:

    action([UserController::class, 'index']);

    return Redirect::action([UserController::class, 'index']);

Если Вы предпочитаете префикс маршрута контроллера в стиле Laravel 7.x, Вы можете просто добавить свойство `$namespace` в `RouteServiceProvider` Вашего приложения.

> {note} Это изменение касается только новых приложений Laravel 8.x. Приложения, обновляющиеся с Laravel 7.x, по-прежнему будут иметь свойство `$namespace` в их `RouteServiceProvider`.
