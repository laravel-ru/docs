# Роутинг

- [Базовая маршрутизация](#basic-routing)
    - [Перенаправление маршрутов](#redirect-routes)
    - [Представления маршрутов](#view-routes)
- [Параметры маршрута](#route-parameters)
    - [Обязательные параметры](#required-parameters)
    - [Дополнительные параметры](#parameters-optional-parameters)
    - [Ограничения регулярного выражения](#parameters-regular-expression-constraints)
- [Именованные маршруты](#named-routes)
- [Группы маршрутов](#route-groups)
    - [Мидлвары](#route-group-middleware)
    - [Маршрутизация поддоменов](#route-group-subdomain-routing)
    - [Префиксы маршрутов](#route-group-prefixes)
    - [Префиксы имени маршрута](#route-group-name-prefixes)
- [Привязка модели маршрута](#route-model-binding)
    - [Неявная привязка](#implicit-binding)
    - [Явная привязка](#explicit-binding)
- [Резервные маршруты](#fallback-routes)
- [Оценка ограничений](#rate-limiting)
    - [Определение ограничителей скорости](#defining-rate-limiters)
    - [Прикрепление ограничителей скорости к маршрутам](#attaching-rate-limiters-to-routes)
- [Способ подмены формы](#form-method-spoofing)
- [Доступ к текущему маршруту](#accessing-the-current-route)
- [Совместное использование ресурсов (CORS)](#cors)
- [Кэширование маршрутов](#route-caching)

<a name="basic-routing"></a>
## Базовая маршрутизация

Самые основные маршруты Laravel принимают URI и закрытие, обеспечивая очень простой и выразительный метод определения маршрутов и поведения без сложных файлов конфигурации маршрутизации:

    use Illuminate\Support\Facades\Route;

    Route::get('/greeting', function () {
        return 'Привет мир!';
    });

<a name="the-default-route-files"></a>
#### Файлы роута по умолчанию

Все маршруты Laravel определены в Ваших файлах маршрутов, которые находятся в каталоге `routes`. Эти файлы автоматически загружаются Вашим приложением `App\Providers\RouteServiceProvider`. Файл `routes/web.php` определяет маршруты для вашего веб-интерфейса. Этим маршрутам назначается группа мидлваров `web`, которая обеспечивает такие функции, как состояние сеанса и защита CSRF. Маршруты в `routes/api.php` не сохраняют состояния и назначаются группе мидлваров `api`.

Для большинства приложений Вы начнете с определения маршрутов в файле `routes/web.php`. К маршрутам, определенным в `routes/web.php`, можно получить доступ, введя URL-адрес определенного маршрута в Вашем браузере. Например, Вы можете получить доступ к следующему маршруту, перейдя по адресу `http://example.com/user` в Вашем браузере:

    use App\Http\Controllers\UserController;

    Route::get('/user', [UserController::class, 'index']);

Маршруты, определенные в файле `routes/api.php`, вложены в группу маршрутов с помощью `RouteServiceProvider`. Внутри этой группы автоматически применяется префикс URI `/api`, поэтому Вам не нужно вручную применять его к каждому маршруту в файле. Вы можете изменить префикс и другие параметры группы маршрутов, изменив свой класс `RouteServiceProvider`.

<a name="available-router-methods"></a>
#### Доступные методы маршрутизатора

Маршрутизатор позволяет регистрировать маршруты, отвечающие на любую команду HTTP:

    Route::get($uri, $callback);
    Route::post($uri, $callback);
    Route::put($uri, $callback);
    Route::patch($uri, $callback);
    Route::delete($uri, $callback);
    Route::options($uri, $callback);

Иногда Вам может потребоваться зарегистрировать маршрут, который отвечает на несколько методов HTTP-запросов. Вы можете сделать это с помощью метода `match`. Или Вы даже можете зарегистрировать маршрут, который отвечает на все HTTP-команды, используя метод `any`:

    Route::match(['get', 'post'], '/', function () {
        //
    });

    Route::any('/', function () {
        //
    });

<a name="dependency-injection"></a>
#### Внедрение зависимости (DI)

Вы можете указать любые зависимости, необходимые для Вашего маршрута, в сигнатуре обратного вызова Вашего маршрута. Объявленные зависимости будут автоматически разрешены и введены в обратный вызов Laravel [сервисный контейнер](/docs/{{version}}/container). Например, Вы можете указать класс `Illuminate\Http\Request`, чтобы текущий HTTP-запрос автоматически вставлялся в обратный вызов Вашего маршрута:

    use Illuminate\Http\Request;

    Route::get('/users', function (Request $request) {
        // ...
    });

<a name="csrf-protection"></a>
#### CSRF защита

Помните, что любые HTML-формы, указывающие на маршруты `POST`, `PUT`, `PATCH` или `DELETE`, которые определены в файле маршрутов `web`, должны включать поле токена CSRF. В противном случае запрос будет отклонен. Вы можете узнать больше о защите CSRF в [документации CSRF](/docs/{{version}}/csrf):

    <form method="POST" action="/profile">
        @csrf
        ...
    </form>

<a name="redirect-routes"></a>
### Перенаправление маршрутов

Если Вы определяете маршрут, который перенаправляет на другой URI, Вы можете использовать метод `Route::redirect`. Этот метод предоставляет удобное сокращение, так что Вам не нужно определять полный маршрут или контроллер для выполнения простого перенаправления:

    Route::redirect('/here', '/there');

По умолчанию `Route::redirect` возвращает код состояния`302`. Вы можете настроить код состояния, используя необязательный третий параметр:

    Route::redirect('/here', '/there', 301);

Или вы можете использовать метод `Route::permanentRedirect` для возврата кода состояния `301`:

    Route::permanentRedirect('/here', '/there');

> {note} При использовании параметров маршрута в маршрутах перенаправления следующие параметры зарезервированы Laravel и не могут использоваться: `destination` и `status`.

<a name="view-routes"></a>
### Представления маршрутов

Если Ваш маршрут должен возвращать только [представление](/docs/{{version}}/views), Вы можете использовать метод `Route::view`. Как и метод `redirect`, этот метод предоставляет простое сокращение, так что Вам не нужно определять полный маршрут или контроллер. Метод `view` принимает URI в качестве первого аргумента и имя представления в качестве второго аргумента. Кроме того, Вы можете предоставить массив данных для передачи в представление в качестве необязательного третьего аргумента:

    Route::view('/welcome', 'welcome');

    Route::view('/welcome', 'welcome', ['name' => 'Taylor']);

> {note} При использовании параметров маршрута в маршрутах просмотра следующие параметры зарезервированы Laravel и не могут быть использованы: `view`, `data`, `status` и `headers`.

<a name="route-parameters"></a>
## Параметры маршрута

<a name="required-parameters"></a>
### Обязательные параметры

Иногда Вам нужно будет захватить сегменты URI в Вашем маршруте. Например, Вам может потребоваться захватить идентификатор пользователя из URL-адреса. Вы можете сделать это, указав параметры маршрута:

    Route::get('/user/{id}', function ($id) {
        return 'User '.$id;
    });

Вы можете определить столько параметров маршрута, сколько требуется для Вашего маршрута:

    Route::get('/posts/{post}/comments/{comment}', function ($postId, $commentId) {
        //
    });

Параметры маршрута всегда заключаются в фигурные скобки `{}` и должны состоять из буквенных символов. Подчеркивание (`_`) также допускается в именах параметров маршрута. Параметры маршрута вводятся в обратные вызовы / контроллеры маршрутов в зависимости от их порядка - имена аргументов обратного вызова / контроллера маршрута не имеют значения.

<a name="parameters-and-dependency-injection"></a>
#### Параметры и внедрение зависимостей (DI)

Если Ваш маршрут имеет зависимости, которые Вы хотели бы, чтобы сервисный контейнер Laravel автоматически вставлял в обратный вызов Вашего маршрута, Вы должны указать свои параметры маршрута после Ваших зависимостей:

    use Illuminate\Http\Request;

    Route::get('/user/{id}', function (Request $request, $id) {
        return 'User '.$id;
    });

<a name="parameters-optional-parameters"></a>
### Дополнительные параметры

Иногда Вам может потребоваться указать параметр маршрута, который не всегда может присутствовать в URI. Вы можете сделать это, поставив знак `?` После имени параметра. Не забудьте присвоить соответствующей переменной маршрута значение по умолчанию:

    Route::get('/user/{name?}', function ($name = null) {
        return $name;
    });

    Route::get('/user/{name?}', function ($name = 'John') {
        return $name;
    });

<a name="parameters-regular-expression-constraints"></a>
### Ограничения регулярного выражения

Вы можете ограничить формат параметров Вашего маршрута, используя метод `where` в экземпляре маршрута. Метод `where` принимает имя параметра и регулярное выражение, определяющее, как параметр должен быть ограничен:

    Route::get('/user/{name}', function ($name) {
        //
    })->where('name', '[A-Za-z]+');

    Route::get('/user/{id}', function ($id) {
        //
    })->where('id', '[0-9]+');

    Route::get('/user/{id}/{name}', function ($id, $name) {
        //
    })->where(['id' => '[0-9]+', 'name' => '[a-z]+']);

Для удобства в некоторых часто используемых шаблонах регулярных выражений есть вспомогательные методы, которые позволяют быстро добавлять ограничения шаблонов к Вашим маршрутам:

    Route::get('/user/{id}/{name}', function ($id, $name) {
        //
    })->whereNumber('id')->whereAlpha('name');

    Route::get('/user/{name}', function ($name) {
        //
    })->whereAlphaNumeric('name');

    Route::get('/user/{id}', function ($id) {
        //
    })->whereUuid('id');

Если входящий запрос не соответствует ограничениям шаблона маршрута, будет возвращен ответ HTTP 404.

<a name="parameters-global-constraints"></a>
#### Глобальные ограничения

Если Вы хотите, чтобы параметр маршрута всегда ограничивался данным регулярным выражением, Вы можете использовать метод `pattern`. Вы должны определить эти шаблоны в методе `boot` Вашего класса `App\Providers\RouteServiceProvider`:

    /**
     * Определите привязки модели маршрута, фильтры шаблонов и т.д.
     *
     * @return void
     */
    public function boot()
    {
        Route::pattern('id', '[0-9]+');
    }

Как только шаблон определен, он автоматически применяется ко всем маршрутам, использующим это имя параметра:

    Route::get('/user/{id}', function ($id) {
        // Only executed if {id} is numeric...
    });

<a name="parameters-encoded-forward-slashes"></a>
#### Кодирование косой черты

Компонент маршрутизации Laravel позволяет всем символам, кроме `/`, присутствовать в значениях параметров маршрута. Вы должны явно разрешить `/` быть частью Вашего заполнителя, используя регулярное выражение условия `where`:

    Route::get('/search/{search}', function ($search) {
        return $search;
    })->where('search', '.*');

> {note} Кодированные слешей поддерживаются только в пределах последнего сегмента маршрута.

<a name="named-routes"></a>
## Именованные маршруты

Именованные маршруты позволяют удобно генерировать URL-адреса или перенаправления для определенных маршрутов. Вы можете указать имя для маршрута, связав метод `name` с определением маршрута:

    Route::get('/user/profile', function () {
        //
    })->name('profile');

Вы также можете указать имена маршрутов для действий контроллера:

    Route::get(
        '/user/profile',
        [UserProfileController::class, 'show']
    )->name('profile');

> {note} Имена маршрутов всегда должны быть уникальными.

<a name="generating-urls-to-named-routes"></a>
#### Создание URL-адресов для именованных маршрутов

После того, как Вы присвоили имя данному маршруту, Вы можете использовать имя маршрута при генерации URL-адресов или перенаправлений с помощью вспомогательных функций Laravel `route` и `redirect`:

    // Генерация URL-адресов...
    $url = route('profile');

    // Генерация редиректов...
    return redirect()->route('profile');

Если именованный маршрут определяет параметры, Вы можете передать параметры в качестве второго аргумента функции `route`. Указанные параметры будут автоматически вставлены в сгенерированный URL в их правильных местах:

    Route::get('/user/{id}/profile', function ($id) {
        //
    })->name('profile');

    $url = route('profile', ['id' => 1]);

Если Вы передадите дополнительные параметры в массиве, эти пары ключ / значение будут автоматически добавлены в сгенерированную строку запроса URL:

    Route::get('/user/{id}/profile', function ($id) {
        //
    })->name('profile');

    $url = route('profile', ['id' => 1, 'photos' => 'yes']);

    // /user/1/profile?photos=yes

> {tip} Иногда Вам может потребоваться указать значения по умолчанию для всего запроса для параметров URL, например, текущий языковой стандарт. Для этого Вы можете использовать [метод `URL::defaults`](/docs/{{version}}/urls#default-values).

<a name="inspecting-the-current-route"></a>
#### Проверка текущего маршрута

Если Вы хотите определить, был ли текущий запрос направлен на заданный именованный маршрут, Вы можете использовать метод `named` в экземпляре `Route`. Например, Вы можете проверить имя текущего маршрута из мидлвара маршрута:

    /**
     * Обработка входящего запроса.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle($request, Closure $next)
    {
        if ($request->route()->named('profile')) {
            //
        }

        return $next($request);
    }

<a name="route-groups"></a>
## Группы маршрутов

Группы маршрутов позволяют Вам совместно использовать атрибуты маршрута, такие как мидлвары, по большому количеству маршрутов без необходимости определять эти атрибуты для каждого отдельного маршрута.

Вложенные группы пытаются разумно «объединить» атрибуты со своей родительской группой. Мидлвары и условия `where` объединяются, а имена и префиксы добавляются. Разделители пространства имен и косая черта в префиксах URI добавляются автоматически, где это необходимо.

<a name="route-group-middleware"></a>
### Мидлвары

Чтобы назначить [мидлвары](/docs/{{version}}/middleware) всем маршрутам в группе, Вы можете использовать метод `middleware` перед определением группы. Промежуточное ПО выполняется в том порядке, в котором они перечислены в массиве:

    Route::middleware(['first', 'second'])->group(function () {
        Route::get('/', function () {
            // Используется первый и второй мидлвары...
        });

        Route::get('/user/profile', function () {
            // Используется первый и второй мидлвары...
        });
    });

<a name="route-group-subdomain-routing"></a>
### Маршрутизация поддоменов

Группы маршрутов также могут использоваться для управления маршрутизацией поддоменов. Поддоменам могут быть назначены параметры маршрута так же, как и URI маршрута, что позволяет Вам захватывать часть поддомена для использования в Вашем маршруте или контроллере. Поддомен можно указать, вызвав метод `domain` перед определением группы:

    Route::domain('{account}.example.com')->group(function () {
        Route::get('user/{id}', function ($account, $id) {
            //
        });
    });

> {note} Чтобы обеспечить доступность маршрутов поддоменов, Вы должны зарегистрировать маршруты поддоменов перед регистрацией маршрутов корневого домена. Это предотвратит перезапись маршрутами корневого домена маршрутов поддоменов, имеющих одинаковый путь URI.

<a name="route-group-prefixes"></a>
### Префиксы маршрутов

Метод `prefix` может использоваться для префикса каждого маршрута в группе заданным URI. Например, Вы можете захотеть поставить перед всеми URI маршрутов в группе префикс `admin`:

    Route::prefix('admin')->group(function () {
        Route::get('/users', function () {
            // Соответствует URL-адресу "/admin/users"
        });
    });

<a name="route-group-name-prefixes"></a>
### Префиксы имени маршрута

Метод `name` может использоваться для префикса каждого имени маршрута в группе заданной строкой. Например, Вы можете захотеть поставить перед всеми именами сгруппированных маршрутов префикс `admin`. Данная строка ставится перед именем маршрута точно в том виде, в котором она указана, поэтому мы обязательно предоставим завершающий символ `.` в префиксе:

    Route::name('admin.')->group(function () {
        Route::get('/users', function () {
            // Маршруту присвоено имя "admin.users"...
        })->name('users');
    });

<a name="route-model-binding"></a>
## Привязка модели маршрута

При введении идентификатора модели в действие маршрута или контроллера Вы часто будете запрашивать базу данных, чтобы получить модель, соответствующую этому идентификатору. Привязка модели маршрута Laravel обеспечивает удобный способ автоматического внедрения экземпляров модели непосредственно в Ваши маршруты. Например, вместо того, чтобы вводить идентификатор пользователя, Вы можете внедрить весь экземпляр модели `User`, который соответствует данному идентификатору.

<a name="implicit-binding"></a>
### Неявная привязка

Laravel автоматически разрешает модели Eloquent, определенные в маршрутах или действиях контроллера, чьи имена переменных с указанием типа соответствуют имени сегмента маршрута. Например:

    use App\Models\User;

    Route::get('/users/{user}', function (User $user) {
        return $user->email;
    });

Так как переменная `$user` имеет типовой намек как модель `App\Models\User` и имя переменной соответствует сегменту URI `{user}`, Laravel автоматически внедрит экземпляр модели, идентификатор которого соответствует соответствующему значение из URI запроса. Если соответствующий экземпляр модели не найден в базе данных, автоматически будет сгенерирован ответ HTTP 404.

Конечно, неявная привязка также возможна при использовании методов контроллера. Опять же, обратите внимание, что сегмент URI `{user}` соответствует переменной `$user` в контроллере, которая содержит подсказку типа `App\Models\User`:

    use App\Http\Controllers\UserController;
    use App\Models\User;

    // Определение маршрута...
    Route::get('/users/{user}', [UserController::class, 'show']);

    // Определение метода контроллера...
    public function show(User $user)
    {
        return view('user.profile', ['user' => $user]);
    }

<a name="customizing-the-key"></a>
<a name="customizing-the-default-key-name"></a>
#### Настройка ключа

Иногда Вы можете захотеть разрешить модели Eloquent, используя столбец, отличный от `id`. Для этого Вы можете указать столбец в определении параметра маршрута:

    use App\Models\Post;

    Route::get('/posts/{post:slug}', function (Post $post) {
        return $post;
    });

Если Вы хотите, чтобы привязка модели всегда использовала столбец базы данных, отличный от `id`, при извлечении данного класса модели, Вы можете переопределить метод `getRouteKeyName` в модели Eloquent:

    /**
     * Получите ключ маршрута для модели.
     *
     * @return string
     */
    public function getRouteKeyName()
    {
        return 'slug';
    }

<a name="implicit-model-binding-scoping"></a>
#### Пользовательские ключи и область действия

При неявном связывании нескольких моделей Eloquent в одном определении маршрута, Вы можете захотеть охватить вторую модель Eloquent так, чтобы она была дочерней по отношению к предыдущей модели Eloquent. Например, рассмотрим это определение маршрута, которое извлекает сообщение в блоге по слагу для определенного пользователя:

    use App\Models\Post;
    use App\Models\User;

    Route::get('/users/{user}/posts/{post:slug}', function (User $user, Post $post) {
        return $post;
    });

При использовании настраиваемой неявной привязки с ключом в качестве параметра вложенного маршрута Laravel автоматически задает область запроса для получения вложенной модели своим родителем, используя соглашения, чтобы угадать имя отношения на родительском элементе. В этом случае предполагается, что модель `User` имеет отношение с именем `posts` (форма множественного числа имени параметра маршрута), которое можно использовать для получения модели `Post`.

<a name="explicit-binding"></a>
### Явная привязка

Вам не обязательно использовать неявное разрешение модели на основе соглашений Laravel, чтобы использовать привязку модели. Вы также можете явно определить, как параметры маршрута соответствуют моделям. Чтобы зарегистрировать явную привязку, используйте метод маршрутизатора `model`, чтобы указать класс для данного параметра. Вы должны определить свои явные привязки модели в начале метода `boot` Вашего класса `RouteServiceProvider`:

    use App\Models\User;
    use Illuminate\Support\Facades\Route;

    /**
     * Определите привязки модели маршрута, фильтры шаблонов и т.д.
     *
     * @return void
     */
    public function boot()
    {
        Route::model('user', User::class);

        // ...
    }

Затем определите маршрут, содержащий параметр `{user}`:

    use App\Models\User;

    Route::get('/users/{user}', function (User $user) {
        //
    });

Поскольку мы связали все параметры `{user}` с моделью `App\Models\User`, экземпляр этого класса будет вставлен в маршрут. Так, например, запрос к `users/1` будет внедрять экземпляр `User` из базы данных с идентификатором `1`.

Если соответствующий экземпляр модели не найден в базе данных, автоматически будет сгенерирован HTTP-ответ 404.

<a name="customizing-the-resolution-logic"></a>
#### Настройка логики разрешения

Если Вы хотите определить свою собственную логику разрешения привязки модели, Вы можете использовать метод `Route::bind`. Замыкание, которое Вы передаете методу `bind`, получит значение сегмента URI и должно вернуть экземпляр класса, который должен быть введен в маршрут. Опять же, эта настройка должна выполняться в методе `boot` Вашего приложения `RouteServiceProvider`:

    use App\Models\User;
    use Illuminate\Support\Facades\Route;

    /**
     * Определите привязки модели маршрута, фильтры шаблонов и т.д.
     *
     * @return void
     */
    public function boot()
    {
        Route::bind('user', function ($value) {
            return User::where('name', $value)->firstOrFail();
        });

        // ...
    }

В качестве альтернативы Вы можете переопределить метод `resolveRouteBinding` в Вашей модели Eloquent. Этот метод получит значение сегмента URI и должен вернуть экземпляр класса, который должен быть введен в маршрут:

    /**
     * Получить модель для привязанного значения.
     *
     * @param  mixed  $value
     * @param  string|null  $field
     * @return \Illuminate\Database\Eloquent\Model|null
     */
    public function resolveRouteBinding($value, $field = null)
    {
        return $this->where('name', $value)->firstOrFail();
    }

Если в маршруте используется [неявная область действия привязки](#implicit-model-binding-scoping), для разрешения дочерней привязки родительской модели будет использоваться метод `resolveChildRouteBinding`:

    /**
     * Получить дочернюю модель для привязанного значения.
     *
     * @param  string  $childType
     * @param  mixed  $value
     * @param  string|null  $field
     * @return \Illuminate\Database\Eloquent\Model|null
     */
    public function resolveChildRouteBinding($childType, $value, $field)
    {
        return parent::resolveChildRouteBinding($childType, $value, $field);
    }

<a name="fallback-routes"></a>
## Резервные маршруты

Используя метод `Route::fallback`, Вы можете определить маршрут, который будет выполняться, когда ни один другой маршрут не соответствует входящему запросу. Как правило, необработанные запросы автоматически отображают страницу «404» через обработчик исключений Вашего приложения. Однако, поскольку Вы обычно определяете резервный маршрут `fallback` в своем файле `routes/web.php`, все мидлвары в группе мидлваров `web` будет применяться к этому маршруту. При необходимости Вы можете добавить дополнительный слой мидлвара к этому маршруту:

    Route::fallback(function () {
        //
    });

> {note} Резервный маршрут всегда должен быть последним маршрутом, зарегистрированным Вашим приложением.

<a name="rate-limiting"></a>
## Оценка ограничений

<a name="defining-rate-limiters"></a>
### Определение ограничителей скорости

Laravel включает мощные и настраиваемые службы ограничения скорости, которые Вы можете использовать для ограничения объема трафика для данного маршрута или группы маршрутов. Для начала Вы должны определить конфигурации ограничителя скорости, которые соответствуют потребностям вВашего приложения. Как правило, это должно выполняться в методе `configureRateLimiting` класса `App\Providers\RouteServiceProvider` Вашего приложения.

Ограничители скорости определяются с помощью метод `for` фасада `RateLimiter`. Метод `for` принимает имя ограничителя скорости и закрытие, которое возвращает конфигурацию ограничения, которая должна применяться к маршрутам, назначенным ограничителю скорости. Конфигурация ограничений - это экземпляры класса `Illuminate\Cache\RateLimiting\Limit`. Этот класс содержит полезные методы построения, чтобы Вы могли быстро определить свой лимит. Имя ограничителя скорости может быть любой строкой по Вашему желанию:

    use Illuminate\Cache\RateLimiting\Limit;
    use Illuminate\Support\Facades\RateLimiter;

    /**
     * Настройте ограничители скорости для приложения.
     *
     * @return void
     */
    protected function configureRateLimiting()
    {
        RateLimiter::for('global', function (Request $request) {
            return Limit::perMinute(1000);
        });
    }

Если входящий запрос превышает указанный предел скорости, Laravel автоматически вернет ответ с кодом состояния HTTP 429. Если Вы хотите определить свой собственный ответ, который должен возвращаться ограничением скорости, Вы можете использовать метод `response`:

    RateLimiter::for('global', function (Request $request) {
        return Limit::perMinute(1000)->response(function () {
            return response('Custom response...', 429);
        });
    });

Поскольку обратные вызовы ограничителя скорости получают экземпляр входящего HTTP-запроса, Вы можете динамически создать соответствующее ограничение скорости на основе входящего запроса или аутентифицированного пользователя:

    RateLimiter::for('uploads', function (Request $request) {
        return $request->user()->vipCustomer()
                    ? Limit::none()
                    : Limit::perMinute(100);
    });

<a name="segmenting-rate-limits"></a>
#### Пределы скорости сегментации

Иногда Вы можете захотеть сегментировать ограничения скорости на какое-то произвольное значение. Например, Вы можете разрешить пользователям получать доступ к заданному маршруту 100 раз в минуту на каждый IP-адрес. Для этого Вы можете использовать метод `by` при построении лимита скорости:

    RateLimiter::for('uploads', function (Request $request) {
        return $request->user()->vipCustomer()
                    ? Limit::none()
                    : Limit::perMinute(100)->by($request->ip());
    });

<a name="multiple-rate-limits"></a>
#### Множественные ограничения скорости

При необходимости Вы можете вернуть массив ограничений скорости для данной конфигурации ограничителя скорости. Каждое ограничение скорости будет оцениваться для маршрута на основе порядка, в котором они размещены в массиве:

    RateLimiter::for('login', function (Request $request) {
        return [
            Limit::perMinute(500),
            Limit::perMinute(3)->by($request->input('email')),
        ];
    });

<a name="attaching-rate-limiters-to-routes"></a>
### Прикрепление ограничителей скорости к маршрутам

Ограничители скорости могут быть прикреплены к маршрутам или группам маршрутов с помощью `throttle` [мидлвара](/docs/{{version}}/middleware). Мидлвар `throttle` принимает имя ограничителя скорости, которое Вы хотите назначить маршруту:

    Route::middleware(['throttle:uploads'])->group(function () {
        Route::post('/audio', function () {
            //
        });

        Route::post('/video', function () {
            //
        });
    });

<a name="throttling-with-redis"></a>
#### Регулирование с помощью Redis

Как правило, мидлвар `throttle` отображается в класс `Illuminate\Routing\Middleware\ThrottleRequests`. Это отображение определено в ядре HTTP Вашего приложения (`App\Http\Kernel`). Однако, если Вы используете Redis в качестве драйвера кеша Вашего приложения, Вы можете изменить это сопоставление, чтобы использовать класс `Illuminate\Routing\Middleware\ThrottleRequestsWithRedis`. Этот класс более эффективен при управлении ограничением скорости с помощью Redis:

    'throttle' => \Illuminate\Routing\Middleware\ThrottleRequestsWithRedis::class,

<a name="form-method-spoofing"></a>
## Способ подмены формы

HTML-формы не поддерживают действия `PUT`, `PATCH` или `DELETE`. Таким образом, при определении маршрутов `PUT`, `PATCH` или `DELETE` , которые вызываются из HTML-формы, Вам нужно будет добавить в форму скрытое поле `_method`. Значение, отправленное с полем `_method`, будет использоваться как метод HTTP-запроса::

    <form action="/example" method="POST">
        <input type="hidden" name="_method" value="PUT">
        <input type="hidden" name="_token" value="{{ csrf_token() }}">
    </form>

Для удобства вы можете использовать `@method` [директиву шаблонизатора Blade](/docs/{{version}}/blade) для создания поля ввода `_method`:

    <form action="/example" method="POST">
        @method('PUT')
        @csrf
    </form>

<a name="accessing-the-current-route"></a>
## Доступ к текущему маршруту

Вы можете использовать методы `current`, `currentRouteName` и `currentRouteAction` на фасаде `Route` для доступа к информации о маршруте, обрабатывающем входящий запрос:

    use Illuminate\Support\Facades\Route;

    $route = Route::current(); // Illuminate\Routing\Route
    $name = Route::currentRouteName(); // string
    $action = Route::currentRouteAction(); // string

Вы можете обратиться к документации API для [базового класса фасада Route](https://laravel.com/api/{{version}}/Illuminate/Routing/Router.html) и [экземпляра маршрута](https://laravel.com/api/{{version}}/Illuminate/Routing/Route.html), чтобы просмотреть все методы, доступные в классах маршрутизатора и маршрута.

<a name="cors"></a>
## Совместное использование ресурсов (CORS)

Laravel может автоматически отвечать на HTTP-запросы CORS `OPTIONS` значениями, которые Вы настраиваете. Все параметры CORS могут быть настроены в файле конфигурации Вашего приложения `config/cors.php`. Запросы `OPTIONS` будут автоматически обрабатываться `HandleCors` [мидлваром](/docs/{{version}}/middleware), которое по умолчанию включено в Ваш глобальный стек мидлвара. Ваш глобальный стек мидлвара находится в HTTP-ядре Вашего приложения (`App\Http\Kernel`).

> {tip} Для получения дополнительной информации о заголовках CORS и CORS обратитесь к [веб-документации MDN по CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#The_HTTP_response_headers).

<a name="route-caching"></a>
## Кэширование маршрутов

При деплои Вашего приложения в продакшен среде Вы должны воспользоваться кешем маршрутов Laravel. Использование кеша маршрутов значительно сократит время, необходимое для регистрации всех маршрутов Вашего приложения. Чтобы сгенерировать кеш маршрута, выполните Artisan-команду `route:cache`:

    php artisan route:cache

После выполнения этой команды Ваш кешированный файл маршрутов будет загружаться при каждом запросе. Помните, что если Вы добавляете какие-либо новые маршруты, Вам нужно будет сгенерировать новый кеш маршрутов. По этой причине Вы должны запускать команду `route:cache` только во время развертывания Вашего проекта.

Вы можете использовать команду `route:clear` для очистки кеша маршрута:

    php artisan route:clear
