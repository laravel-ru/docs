# Представления

- [Введение](#introduction)
- [Создание и рендеринг представлений](#creating-and-rendering-views)
    - [Вложенные каталоги представлений](#nested-view-directories)
    - [Создание первого доступного представления](#creating-the-first-available-view)
    - [Определение наличия представления](#determining-if-a-view-exists)
- [Передача данных в представления](#passing-data-to-views)
    - [Совместное использование данных со всеми представлениями](#sharing-data-with-all-views)
- [Композеры представлений](#view-composers)
    - [Создатели представлений](#view-creators)
- [Оптимизация представлений](#optimizing-views)

<a name="introduction"></a>
## Введение

Конечно, нецелесообразно возвращать целые строки HTML-документов непосредственно из Ваших маршрутов и контроллеров. К счастью, представления предоставляют удобный способ разместить весь наш HTML в отдельных файлах. Представления отделяют логику контроллера / приложения от логики представления и хранятся в каталоге `resources/views`. Простой вид может выглядеть примерно так:

```html
<!-- Представления хранятся в файлах resources/views/greeting.blade.php -->

<html>
    <body>
        <h1>Привет, {{ $name }}</h1>
    </body>
</html>
```

Поскольку это представление хранится в файле `resources/views/greeting.blade.php`, мы можем вернуть его, используя глобальный помощник `view`, например:

    Route::get('/', function () {
        return view('greeting', ['name' => 'James']);
    });

> {tip} Ищете дополнительную информацию о том, как писать шаблоны Blade? Ознакомьтесь с полной [документацией по Blade](/docs/{{version}}/blade), чтобы начать работу.

<a name="creating-and-rendering-views"></a>
## Создание и рендеринг представлений

Вы можете создать представление, поместив файл с расширением `.blade.php` в каталог `resources/views` Вашего приложения. Расширение `.blade.php` сообщает платформе, что файл содержит [шаблон Blade](/docs/{{version}}/blade). Шаблоны Blade содержат HTML, а также директивы Blade, которые позволяют легко отображать значения, создавать операторы «если», выполнять итерацию по данным и многое другое.

После того, как Вы создали представление, Вы можете вернуть его из одного из маршрутов или контроллеров Вашего приложения, используя глобальный помощник `view`:

    Route::get('/', function () {
        return view('greeting', ['name' => 'James']);
    });

Представления также могут быть возвращены с помощью фасада `View`:

    use Illuminate\Support\Facades\View;

    return View::make('greeting', ['name' => 'James']);

Как видите, первый аргумент, переданный помощнику `view`, соответствует имени файла представления в каталоге `resources/views`. Второй аргумент - это массив данных, которые должны быть доступны для представления. В этом случае мы передаем переменную `name`, которая отображается в представлении с использованием [синтаксиса Blade](/docs/{{version}}/blade).

<a name="nested-view-directories"></a>
### Вложенные каталоги представлений

Представления также могут быть вложены в подкаталоги каталога `resources/views`. Обозначение «точка» может использоваться для ссылки на вложенные представления. Например, если Ваше представление хранится в `resources/views/admin/profile.blade.php`, Вы можете вернуть его из одного из маршрутов / контроллеров Вашего приложения следующим образом:

    return view('admin.profile', $data);

> {note} Имена каталогов просмотра не должны содержать символа `.`.

<a name="creating-the-first-available-view"></a>
### Создание первого доступного представления

Используя метод `first` фасада `View`, Вы можете создать первое представление, которое существует в данном массиве представлений. Это может быть полезно, если Ваше приложение или пакет позволяет настраивать или перезаписывать представления:

    use Illuminate\Support\Facades\View;

    return View::first(['custom.admin', 'admin'], $data);

<a name="determining-if-a-view-exists"></a>
### Определение наличия представления

Если Вам нужно определить, существует ли представление, Вы можете использовать фасад `View`. Метод `exists` вернет `true`, если представление существует:

    use Illuminate\Support\Facades\View;

    if (View::exists('emails.customer')) {
        //
    }

<a name="passing-data-to-views"></a>
## Передача данных в представления

Как Вы видели в предыдущих примерах, Вы можете передать массив данных представлениям, чтобы сделать эти данные доступными для представления:

    return view('greetings', ['name' => 'Victoria']);

При передаче информации таким образом данные должны быть массивом с парами ключ / значение. После предоставления данных в представление Вы можете получить доступ к каждому значению в Вашем представлении, используя ключи данных, такие как `<?php echo $name; ?>`.

В качестве альтернативы передаче полного массива данных вспомогательной функции `view` Вы можете использовать метод `with` для добавления отдельных частей данных в представление. Метод `with` возвращает экземпляр объекта представления, так что Вы можете продолжить связывание методов перед возвратом представления:

    return view('greeting')
                ->with('name', 'Victoria')
                ->with('occupation', 'Astronaut');

<a name="sharing-data-with-all-views"></a>
### Совместное использование данных со всеми представлениями

Иногда Вам может потребоваться поделиться данными со всеми представлениями, отображаемыми Вашим приложением. Вы можете сделать это, используя метод `share` фасада `View`. Как правило, Вы должны размещать вызовы метода `share` внутри метода `boot` сервис контейнера. Вы можете добавить их в класс `App\Providers\AppServiceProvider` или создать отдельного сервис провайдера для их размещения:

    <?php

    namespace App\Providers;

    use Illuminate\Support\Facades\View;

    class AppServiceProvider extends ServiceProvider
    {
        /**
         * Зарегистрируйте любые сервисы приложения.
         *
         * @return void
         */
        public function register()
        {
            //
        }

        /**
         * Загрузите любые сервисы приложений.
         *
         * @return void
         */
        public function boot()
        {
            View::share('key', 'value');
        }
    }

<a name="view-composers"></a>
## Композеры представлений

Композеры представлений - это обратные вызовы или методы класса, которые вызываются при визуализации представления. Если у Вас есть данные, которые Вы хотите привязать к представлению каждый раз при его визуализации, составитель представления может помочь Вам организовать эту логику в одном месте. Композеры представлений могут оказаться особенно полезными, если одно и то же представление возвращается несколькими маршрутами или контроллерами в Вашем приложении и всегда требует определенного фрагмента данных.

Как правило, композеры представлений будут зарегистрированы в одном из [сервис провайдеров](/docs/{{version}}/providers) Вашего приложения. В этом примере мы предположим, что мы создали новый `App\Providers\ViewServiceProvider` для размещения этой логики.

Мы будем использовать метод `composer` фасада `View`, чтобы зарегистрировать композер представления. Laravel не включает каталог по умолчанию для композеров представлений на основе классов, поэтому Вы можете организовать их, как хотите. Например, Вы можете создать каталог `app/Http/View/Composers` для размещения всех композеров представлений Вашего приложения:

    <?php

    namespace App\Providers;

    use App\Http\View\Composers\ProfileComposer;
    use Illuminate\Support\Facades\View;
    use Illuminate\Support\ServiceProvider;

    class ViewServiceProvider extends ServiceProvider
    {
        /**
         * Зарегистрируйте любые сервисы приложения.
         *
         * @return void
         */
        public function register()
        {
            //
        }

        /**
         * Загрузите любые сервисы приложений.
         *
         * @return void
         */
        public function boot()
        {
            // Using class based composers...
            View::composer('profile', ProfileComposer::class);

            // Using closure based composers...
            View::composer('dashboard', function ($view) {
                //
            });
        }
    }

> {note} Помните, что если вы создаете нового сервис провайдера, который будет содержать регистрации Вашего композера представления, Вам нужно будет добавить сервис провайдера в массив провайдеров `providers` в файле конфигурации `config/app.php`.

Теперь, когда мы зарегистрировали композер, метод `compose` класса `App\Http\View\Composers\ProfileComposer` будет выполняться каждый раз, когда визуализируется представление профиля `profile`. Давайте посмотрим на пример класса композера:

    <?php

    namespace App\Http\View\Composers;

    use App\Repositories\UserRepository;
    use Illuminate\View\View;

    class ProfileComposer
    {
        /**
         * Реализация пользовательского репозитория.
         *
         * @var \App\Repositories\UserRepository
         */
        protected $users;

        /**
         * Создать новый профиль композитора.
         *
         * @param  \App\Repositories\UserRepository  $users
         * @return void
         */
        public function __construct(UserRepository $users)
        {
            // Dependencies are automatically resolved by the service container...
            $this->users = $users;
        }

        /**
         * Привязать данные к представлению.
         *
         * @param  \Illuminate\View\View  $view
         * @return void
         */
        public function compose(View $view)
        {
            $view->with('count', $this->users->count());
        }
    }

Как видите, все композеры представлений разрешаются через [сервисный контейнер](/docs/{{version}}/container), поэтому Вы можете указать любые зависимости, которые Вам нужны, в конструкторе композера.

<a name="attaching-a-composer-to-multiple-views"></a>
#### Прикрепление композера к нескольким представлениям

Вы можете присоединить композер представлений к нескольким представлениям одновременно, передав массив представлений в качестве первого аргумента методу `composer`:

    use App\Http\Views\Composers\MultiComposer;

    View::composer(
        ['profile', 'dashboard'],
        MultiComposer::class
    );

Метод `composer` также принимает символ `*` в качестве подстановочного знака, позволяя Вам прикрепить композер ко всем представлениям:

    View::composer('*', function ($view) {
        //
    });

<a name="view-creators"></a>
### Создатели представлений

Представления «Создатели» очень похожи на композеры представления; однако они выполняются сразу после создания экземпляра представления, вместо того, чтобы ждать, пока представление будет отображено. Чтобы зарегистрировать создателя представления, используйте метод `creator`:

    use App\Http\View\Creators\ProfileCreator;
    use Illuminate\Support\Facades\View;

    View::creator('profile', ProfileCreator::class);

<a name="optimizing-views"></a>
## Оптимизация представлений

По умолчанию представления шаблонов Blade компилируются по запросу. Когда выполняется запрос, который отображает представление, Laravel определит, существует ли скомпилированная версия представления. Если файл существует, Laravel затем определит, было ли некомпилированное представление изменено позже, чем скомпилированное представление. Если скомпилированное представление либо не существует, либо некомпилированное представление было изменено, Laravel перекомпилирует представление.

Компиляция представлений во время запроса может иметь небольшое негативное влияние на производительность, поэтому Laravel предоставляет Artisan-команду `view:cache` для предварительной компиляции всех представлений, используемых Вашим приложением. Для повышения производительности Вы можете выполнить эту команду как часть процесса развертывания:

    php artisan view:cache

Вы можете использовать команду `view:clear` для очистки кеша представлений:

    php artisan view:clear
